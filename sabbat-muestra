#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import argparse
import os
import sys
import subprocess
import stat
import math
import hashlib
import json
import re
from pathlib import Path
from datetime import datetime
import pwd
import grp

# --- Importaci√≥n de dependencias opcionales ---
try:
    import chardet
    CHARDET_AVAILABLE = True
except ImportError:
    CHARDET_AVAILABLE = False

try:
    from PIL import Image
    PILLOW_AVAILABLE = True
except ImportError:
    PILLOW_AVAILABLE = False


# --- FUNCIONES ---

def analizar_riesgos_seguridad(file_path, file_stats, is_symlink=False):
    """Analiza permisos y caracter√≠sticas de riesgo."""
    alertas = []
    mode = file_stats.st_mode

    if not is_symlink:  # Los symlinks no tienen SUID/SGID en la mayor√≠a de sistemas
        if mode & stat.S_ISUID:
            alertas.append("‚ö†Ô∏è  **SUID bit** - Riesgo elevado si no es necesario")
        if mode & stat.S_ISGID:
            alertas.append("‚ö†Ô∏è  **SGID bit** - Riesgo potencial")
        if (mode & 0o777) == 0o777:
            alertas.append("üö® **PERMISOS 777** - EXTREMADAMENTE PELIGROSO")
        elif (mode & stat.S_IWOTH):
            alertas.append("üîì Archivo escribible por otros usuarios (World-writable)")

    # Nombres sensibles
    nombres_riesgo = ['.ssh', '.pem', 'id_rsa', 'password', 'secret', '.env', '.bak', '.tmp', '~']
    path_str = str(file_path).lower()
    if any(riesgo in path_str for riesgo in nombres_riesgo):
        alertas.append("üîç Archivo con nombre potencialmente sensible")

    return alertas

def detectar_secretos_en_texto(file_path, max_size=1024*1024):
    """Detecta patrones de secretos en archivos de texto peque√±os."""
    if file_path.stat().st_size > max_size:
        return []

    secretos = []
    try:
        with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
            contenido = f.read(10000)  # Solo primeros 10KB para rendimiento
    except Exception:
        return []

    # Patrones comunes (case-insensitive)
    patrones = [
        (r'password\s*[:=]\s*["\'][^"\']+', "Contrase√±a en texto claro"),
        (r'api[_-]?key\s*[:=]\s*["\'][^"\']+', "Clave de API"),
        (r'secret\s*[:=]\s*["\'][^"\']+', "Secreto gen√©rico"),
        (r'-----BEGIN [A-Z ]+PRIVATE KEY-----', "Clave privada"),
        (r'aws[_-]?access[_-]?key[_-]?id\s*[:=]\s*["\'][A-Z0-9]{20}', "AWS Access Key"),
        (r'[\d]{4}[\s-]?[\d]{4}[\s-]?[\d]{4}[\s-]?[\d]{4}', "Posible n√∫mero de tarjeta"),
    ]

    for patron, descripcion in patrones:
        if re.search(patron, contenido, re.IGNORECASE | re.MULTILINE):
            secretos.append(f"üîë {descripcion}")

    return secretos

def calcular_hashes(file_path, all_hashes=False):
    """Calcula hashes. SHA256 por defecto, o todos si se especifica."""
    hashes = {}
    algorithms = ['md5', 'sha1', 'sha256'] if all_hashes else ['sha256']

    for algo in algorithms:
        hasher = hashlib.new(algo)
        try:
            with open(file_path, 'rb') as f:
                for chunk in iter(lambda: f.read(4096), b""):
                    hasher.update(chunk)
            hashes[algo] = hasher.hexdigest()
        except (OSError, IOError):
            hashes[algo] = "ERROR (no se pudo leer)"
    return hashes

def format_permissions(mode):
    """Convierte el modo de stat a un formato legible como 'drwxr-xr-x'."""
    perms = []
    if stat.S_ISDIR(mode): perms.append('d')
    elif stat.S_ISLNK(mode): perms.append('l')
    elif stat.S_ISCHR(mode): perms.append('c')
    elif stat.S_ISBLK(mode): perms.append('b')
    else: perms.append('-')

    perms.append('r' if mode & stat.S_IRUSR else '-')
    perms.append('w' if mode & stat.S_IWUSR else '-')
    if mode & stat.S_ISUID:
        perms.append('s' if mode & stat.S_IXUSR else 'S')
    else:
        perms.append('x' if mode & stat.S_IXUSR else '-')

    perms.append('r' if mode & stat.S_IRGRP else '-')
    perms.append('w' if mode & stat.S_IWGRP else '-')
    if mode & stat.S_ISGID:
        perms.append('s' if mode & stat.S_IXGRP else 'S')
    else:
        perms.append('x' if mode & stat.S_IXGRP else '-')

    perms.append('r' if mode & stat.S_IROTH else '-')
    perms.append('w' if mode & stat.S_IWOTH else '-')
    if mode & stat.S_ISVTX:
        perms.append('t' if mode & stat.S_IXOTH else 'T')
    else:
        perms.append('x' if mode & stat.S_IXOTH else '-')
    return "".join(perms)

def get_file_info(file_path_str, follow_symlinks=True):
    """Obtiene informaci√≥n detallada, incluyendo alertas de seguridad."""
    file_path = Path(file_path_str)

    if not file_path.exists():
        raise FileNotFoundError(f"El fichero '{file_path}' no existe.")

    # Manejo de symlinks
    is_symlink = file_path.is_symlink()
    if is_symlink and not follow_symlinks:
        # Analizamos el symlink mismo, no su destino
        resolved_path = None
        try:
            resolved_path = os.readlink(file_path)
        except OSError:
            resolved_path = "ERROR (enlace roto)"
        tipo_mime = "inode/symlink"
        file_stats = file_path.lstat()  # lstat para no seguir el enlace
    else:
        # Seguimos el enlace (comportamiento por defecto)
        resolved_path = None
        try:
            tipo_mime = subprocess.run(
                ["file", "--mime-type", "-b", str(file_path)],
                capture_output=True, text=True, check=True
            ).stdout.strip()
        except (subprocess.CalledProcessError, FileNotFoundError):
            tipo_mime = "application/octet-stream"
        file_stats = file_path.stat()

    permissions = format_permissions(file_stats.st_mode)
    try:
        owner = pwd.getpwuid(file_stats.st_uid).pw_name
    except KeyError:
        owner = str(file_stats.st_uid)
    try:
        group = grp.getgrgid(file_stats.st_gid).gr_name
    except KeyError:
        group = str(file_stats.st_gid)

    size_bytes = file_stats.st_size
    mod_time = datetime.fromtimestamp(file_stats.st_mtime).strftime('%Y-%m-%d %H:%M:%S')
    acc_time = datetime.fromtimestamp(file_stats.st_atime).strftime('%Y-%m-%d %H:%M:%S')
    cre_time = datetime.fromtimestamp(file_stats.st_ctime).strftime('%Y-%m-%d %H:%M:%S')

    info = {
        'nombre': str(file_path),
        'tipo_mime': tipo_mime,
        'tama√±o_bytes': size_bytes,
        'permisos': permissions,
        'propietario': f"{owner}:{group}",
        'fecha_mod': mod_time,
        'fecha_acc': acc_time,
        'fecha_cre': cre_time,
        'inodo': file_stats.st_ino,
        'es_symlink': is_symlink,
        'destino_symlink': resolved_path,
        'detalles_contextuales': [],
        'alertas_seguridad': analizar_riesgos_seguridad(file_path, file_stats, is_symlink)
    }

    # An√°lisis contextual seg√∫n tipo
    if is_symlink and not follow_symlinks:
        info['detalles_contextuales'].append(f"Enlace simb√≥lico a: {resolved_path}")
    elif tipo_mime.startswith('text/'):
        try:
            with open(file_path, 'r', encoding='utf-8', errors='ignore') as f:
                num_lineas = sum(1 for _ in f)
            info['detalles_contextuales'].append(f"{num_lineas} l√≠neas")
        except Exception:
            info['detalles_contextuales'].append("No se pudo contar las l√≠neas")

        # Detecci√≥n de secretos
        secretos = detectar_secretos_en_texto(file_path)
        info['alertas_seguridad'].extend(secretos)

        if CHARDET_AVAILABLE:
            try:
                with open(file_path, 'rb') as f:
                    raw_data = f.read(1024)
                    result = chardet.detect(raw_data)
                    encoding = result['encoding']
                    confidence = result['confidence'] * 100
                    if encoding and confidence > 50:
                        info['detalles_contextuales'].append(f"Encoding: {encoding} ({confidence:.1f}% conf.)")
            except Exception:
                pass
    elif tipo_mime.startswith('image/'):
        if PILLOW_AVAILABLE:
            try:
                with Image.open(file_path) as img:
                    width, height = img.size
                    mode = img.mode
                    detalles_img = [f"Dimensiones: {width}x{height}", f"Formato: {img.format}"]
                    bit_depth = img.info.get('bitdepth')
                    if bit_depth:
                        detalles_img.append(f"{bit_depth}-bit/color {mode}")
                    else:
                        detalles_img.append(f"Modo: {mode}")
                    interlaced = img.info.get('interlace')
                    if interlaced is not None:
                        estado_interlaced = "interlaced" if interlaced else "non-interlaced"
                        detalles_img.append(estado_interlaced)
                    info['detalles_contextuales'].append(", ".join(detalles_img))
            except Exception:
                info['detalles_contextuales'].append("No se pudieron leer los metadatos de la imagen")
        else:
            info['detalles_contextuales'].append("Pillow no est√° instalado para analizar im√°genes.")
    elif tipo_mime in ('application/x-executable', 'application/x-sharedlib'):
        info['detalles_contextuales'].append("Fichero ejecutable (ELF)")
        try:
            result = subprocess.run(
                ['readelf', '-p', '.comment', str(file_path)],
                capture_output=True, text=True, check=True
            ).stdout
            if "GCC:" in result:
                version_info = result.split("GCC:")[1].strip().split('\n')[0]
                info['detalles_contextuales'].append(f"Compilador: GCC {version_info}")
        except Exception:
            pass

    return info

def format_size(bytes_size, option="auto"):
    if option == "bytes": return f"{bytes_size:,} Bytes"
    if option == "kb": return f"{bytes_size / 1024:.2f} KB"
    if option == "mb": return f"{bytes_size / (1024**2):.2f} MB"
    if option == "gb": return f"{bytes_size / (1024**3):.2f} GB"
    if bytes_size == 0: return "0 B"
    size_name = ("B", "KB", "MB", "GB", "TB", "PB")
    i = int(math.floor(math.log(bytes_size, 1024)))
    p = math.pow(1024, i)
    s = round(bytes_size / p, 2)
    return f"{s} {size_name[i]}"

def show_help(script_name):
    help_text = f"""Uso: {script_name} [opciones] <fichero>

Muestra informaci√≥n detallada de un fichero, distinguiendo entre texto y binario.

Opciones de tama√±o:
  -b, --bytes      Mostrar tama√±o exacto en Bytes.
  -k, --kb         Mostrar tama√±o en Kilobytes (KB).
  -m, --mb         Mostrar tama√±o en Megabytes (MB).
  -g, --gb         Mostrar tama√±o en Gigabytes (GB).

Otras opciones:
      --hashes     Calcular y mostrar todos los hashes (MD5, SHA1, SHA256).
                   Por defecto, solo se muestra SHA256.
      --nofollow   No seguir enlaces simb√≥licos (analiza el enlace mismo).
      --json       Salida en formato JSON (ideal para scripts).
  -h, --help       Mostrar esta ayuda.
"""
    print(help_text)

def main():
    nombre_script = Path(sys.argv[0]).name
    parser = argparse.ArgumentParser(add_help=False)

    parser.add_argument("-h", "--help", action="store_true")
    size_group = parser.add_mutually_exclusive_group()
    size_group.add_argument("-b", "--bytes", action="store_true")
    size_group.add_argument("-k", "--kb", action="store_true")
    size_group.add_argument("-m", "--mb", action="store_true")
    size_group.add_argument("-g", "--gb", action="store_true")

    parser.add_argument("--hashes", action="store_true", help="Calcular y mostrar todos los hashes.")
    parser.add_argument("--nofollow", action="store_true", help="No seguir enlaces simb√≥licos.")
    parser.add_argument("--json", action="store_true", help="Salida en formato JSON.")
    parser.add_argument("fichero", nargs='?')
    args = parser.parse_args()

    if args.help or not args.fichero:
        if not args.json:
            show_help(nombre_script)
        sys.exit(0)

    size_option = "auto"
    if args.bytes: size_option = "bytes"
    elif args.kb: size_option = "kb"
    elif args.mb: size_option = "mb"
    elif args.gb: size_option = "gb"

    try:
        info = get_file_info(args.fichero, follow_symlinks=not args.nofollow)
        info_tama√±o = format_size(info['tama√±o_bytes'], size_option)
        hashes = calcular_hashes(args.fichero, all_hashes=args.hashes)

        # A√±adir hashes al info
        info['hashes'] = hashes
        info['tama√±o_formateado'] = info_tama√±o

        if args.json:
            # Preparar para JSON: quitar objetos no serializables
            json_output = {
                'nombre': info['nombre'],
                'tipo_mime': info['tipo_mime'],
                'tama√±o_bytes': info['tama√±o_bytes'],
                'tama√±o_formateado': info['tama√±o_formateado'],
                'permisos': info['permisos'],
                'propietario': info['propietario'],
                'inodo': info['inodo'],
                'es_symlink': info['es_symlink'],
                'destino_symlink': info['destino_symlink'],
                'fechas': {
                    'modificacion': info['fecha_mod'],
                    'acceso': info['fecha_acc'],
                    'cambio_metadatos': info['fecha_cre']
                },
                'detalles_contextuales': info['detalles_contextuales'],
                'alertas_seguridad': info['alertas_seguridad'],
                'hashes': info['hashes']
            }
            print(json.dumps(json_output, indent=2, ensure_ascii=False))
        else:
            # Salida humana
            print(f"\033[1;36mFichero:\033[0m       {info['nombre']}")
            if info['es_symlink'] and not args.nofollow:
                print(f"\033[1;36mDestino:\033[0m       {info['destino_symlink']}")
            print(f"\033[1;36mTipo MIME:\033[0m     {info['tipo_mime']}")
            print(f"\033[1;36mTama√±o:\033[0m        {info_tama√±o}")
            print("-" * 40)
            print(f"\033[1;36mPermisos:\033[0m      {info['permisos']} (Inodo: {info['inodo']})")
            print(f"\033[1;36mPropietario:\033[0m   {info['propietario']}")

            if info['alertas_seguridad']:
                print("\033[1;33mAlertas Seg.:\033[0m")
                for alerta in info['alertas_seguridad']:
                    print(f"               {alerta}")

            print("-" * 40)
            print(f"\033[1;36mModificado:\033[0m    {info['fecha_mod']}")
            print(f"\033[1;36mAccedido:\033[0m      {info['fecha_acc']}")

            if info['detalles_contextuales']:
                print("-" * 40)
                for detalle in info['detalles_contextuales']:
                    print(f"\033[1;32m‚Üí\033[0m {detalle}")

            print("-" * 40)
            print("\033[1;36mIntegridad:\033[0m")
            for algo, h in hashes.items():
                print(f"  {algo.upper()}: {h}")

    except FileNotFoundError as e:
        if args.json:
            print(json.dumps({"error": str(e)}, indent=2))
        else:
            print(f"\033[1;31mError: {e}\033[0m", file=sys.stderr)
        sys.exit(1)
    except Exception as e:
        if args.json:
            print(json.dumps({"error": f"Error inesperado: {str(e)}"}, indent=2))
        else:
            print(f"\033[1;31mError inesperado: {e}\033[0m", file=sys.stderr)
        sys.exit(1)

if __name__ == "__main__":
    main()
